---
title: "Day4: Kubernetes Objects"
seoTitle: "Kubernetes objects, pods, deployments, configmaps"
datePublished: Wed Oct 15 2025 16:28:53 GMT+0000 (Coordinated Universal Time)
cuid: cmgs7h1wx000002l79vs58y9s
slug: day4-kubernetes-objects
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1760544099607/4e6c7e6b-f2ce-4879-a473-69d28c3530b0.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1760545700825/b6dbb9cc-c848-4964-838a-e9a5052c17e1.png
tags: k8s-series

---

## Deployments

* deployment provides a declarative updates pods and replica sets.
    
* It ensures desired state, scaling, rolling updates with zero downtime.
    
* We rarely use ReplicaSet directly; deployment handles it for us.
    

### Use Case

We have an online app store running in kubernetes, we want 3 instances running at all times for reliability, when new version is released it should update without downtime.

deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: online-store
spec:
  replicas: 3
  selector:
    matchLabels:
      app: store
  template:
    metadata:
      labels:
        app: store
    spec:
      containers:
      - name: store-container
        image: mystore:1.0
        ports:
        - containerPort: 80
```

### How it works?

* kunernetes ensures 3 pods of the app are always running.
    
* when you update image: mystore:2.0, deployments rolls out the new version gradually, keeping the app alive.
    

## ReplicaSet

It ensures a specified number of identical pods are always running, automatically replacing any that fail or are deleted.

### Use Case

Imagine a ticket booking app during a festival time, we need 5 identical pods always running to handle sudden traffic spikes. If one pod crashes due to high load, the replica set immediately spins up a new one, ensuring continuous availability for users.

```bash
kubectl apply -f deployment.yaml           #create ReplicaSet
kubectl get rs                             #check replicaSet
kubectl get pods -l app= ticket-app        #check pods created by ReplicaSet
kubectl describe rs ticket-app             # detailed info of rs
kubectl scale rs ticket-app --replicas=7   #scale replicasets
```

## ConfigMap

* It used to store configuration data in key-value pairs separately from application.
    
* It allows to change configs without rebuilding the container.
    

### Use Case

A web application that connects to a database, instead of hardcoding the database URL, username, password in code, we store them in configmap. This way we can update the DB connection details without redeploying the app.

db-configmap.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-db-config
data:
  DATABASE_HOST: db.example.com
  DATABASE_PORT: "5432"
  LOG_LEVEL: debug
```

Read config map details into a pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: myapp:latest
    envFrom:
    - configMapRef:
        name: app-db-config
```

### How it works?

* envFrom, injects all key-values as environment variables inside a pod.
    
* now the app reads DATABASE\_HOST,DATABASE\_PORT, LOG\_LEVEL from configmap instead of hardcoded values.
    

```bash
kubectl apply -f db-congigmap.yaml                #create
kubectl get configmap app-db-config -o yaml       #view content 
kubectl describe configmap app-db-config          #detailed info
```